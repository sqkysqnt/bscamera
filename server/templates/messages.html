<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/styles-messages.css">
    <!--<link rel="stylesheet" href="{{ url_for('static', filename='combined.css') }}">-->
    <title>Chat Messages</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
</head>
<body>
    <div class="chat-container">
        <div class="toolbar">
            <h2>Theatre Chat</h2>
            <div class="username-display" id="username-display"></div>
            <div class="channel-select" id="channel-select">
                <button class="channel-button active" data-channel="cameras">Cameras</button>
                <button class="channel-button" data-channel="audio">Audio</button>
            </div>

        
            <!-- Set username button at the bottom -->
            <div class="set-username-container">
                <div class="channel-management">
                    <button class="settings-button" id="add-channel-button">Add Channel</button>
                    <button class="settings-button" id="remove-channel-button">Remove Channel</button>
                </div>
                <button class="settings-button" id="set-username-button">Set Username</button>
            </div>
        </div>

        <div class="main-chat">
            <div class="chat-window" id="chat-window">
                {% for id, timestamp, sender_name, message, channel, me in messages %}
                <div class="chat-message"
                     data-id="{{ id }}"
                     data-channel="{{ channel }}"
                     data-sender-name="{{ sender_name }}"
                     data-full-text="{{ message|e }}"
                     data-timestamp="{{ timestamp }}">
                    <span class="chat-timestamp">[{{ timestamp }}]</span>
                    <span class="chat-sender">{{ sender_name }}:</span>
                    <span class="chat-text">{{ message|safe }}</span>
                </div>
                {% endfor %}
            </div>

            <div class="chat-input-container">
                <input type="text" class="chat-input" id="message-input" placeholder="Type a message... (Press Enter to send)">
                <input type="file" id="image-input" accept="image/*" capture="camera" style="display: none;">
                <button class="image-button" id="upload-image-button"></button>
                <div class="emoji-container">
                    <button class="emoji-button" id="emoji-button">😊</button>
                    <div class="emoji-menu" id="emoji-menu">
                        <!-- Emojis will be inserted here -->
                    </div>
                </div>
                <button class="chat-send" id="send-button">Send</button>
            </div>
        </div>
    </div>

    <!-- Modal for full message display -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Full Message</span>
                <span class="close-modal" id="close-modal">&times;</span>
            </div>
            <div class="modal-body" id="modal-body">
                <!-- Full message text will be inserted here -->
            </div>
        </div>
    </div>

    <script>
        let channels = [];
        console.log("LOADED: This is my real messages.html version 12, time =", new Date());

        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission !== 'granted') {
                    console.warn('Notifications are disabled by the user.');
                }
            });
        }

        const socket = io();
        let selectedChannel = localStorage.getItem('selectedChannel') || 'cameras';

            // Set the active channel button on page load
        document.addEventListener('DOMContentLoaded', () => {
            const channelButtons = document.querySelectorAll('.channel-button');
            channelButtons.forEach((button) => {
                const channel = button.getAttribute('data-channel');
                if (channel === selectedChannel) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            // Mark all existing messages as either 'chat-me' or 'chat-other'
            const messages = document.querySelectorAll('.chat-message');
            messages.forEach((msg) => {
                const sender = msg.getAttribute('data-sender-name');
                const isMe = (sender === chosenUsername);
                msg.classList.add(isMe ? 'chat-me' : 'chat-other');
            });

            applyFilters();
            scrollToBottom(); // Scroll to the latest message on load
        });

        // Large array of emojis (expand as desired)
        // Here’s a representative large subset of emojis:
        const emojis = [
          ..."😀😃😄😁😆😅😂🤣😊😇🙂🙃😉😌😍🥰😘😗😙😚😋😛😜😝🤑🤗🤔🤨🧐🤓😎🤩🥳😏😒😞😔😟😕🙁☹️😣😖😫😩🥺😢😭😤😠😡🤬🤯😳🥵🥶😱😨😰😥😓🤤😴😪😵🤐🤢🤮🤧😷🤒🤕🤑🥴🤠😈👿👹👺🤡👻💀👽🤖💩🙈🙉🙊👋🤚🖐✋🖖👌✌🤞🤟🤘🤙👍👎👊🤛🤜👏🙌👐🤲🙏"
        ];
        // You can add more emojis if desired.

        function updateUsernameDisplay() {
            const display = document.getElementById('username-display');
            if (chosenUsername) {
                display.textContent = "Username: " + chosenUsername;
            } else {
                display.textContent = "No username set";
            }
        }

        let chosenUsername = localStorage.getItem('username');
        if (!chosenUsername) {
            const deviceInfo = navigator.platform || navigator.userAgent || 'User';
            const baseName = deviceInfo.split(' ')[0];
            chosenUsername = baseName + '-' + Math.floor(Math.random() * 1000);
            localStorage.setItem('username', chosenUsername);
        }
        updateUsernameDisplay();

        document.getElementById('set-username-button').addEventListener('click', () => {
            const oldUsername = chosenUsername;
            const newUsername = prompt("Enter your new username:");
            if (newUsername && newUsername.trim() !== '') {
                chosenUsername = newUsername.trim();
                localStorage.setItem('username', chosenUsername);
                updateUsernameDisplay();
                applyFilters();
                // Inform server of username change
                socket.emit('username_change', { old_username: oldUsername, new_username: chosenUsername });
            }
        });


        function scrollToBottom() {
            const chatWindow = document.getElementById('chat-window');
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // Scroll to the bottom on page load
        document.addEventListener('DOMContentLoaded', () => {
            const channelButtons = document.querySelectorAll('.channel-button');
            channelButtons.forEach((button) => {
                const channel = button.getAttribute('data-channel');
                if (channel === selectedChannel) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });

            applyFilters();
            scrollToBottom(); // Scroll to the latest message on load
        });

        socket.on('new_message', (data) => {
            const chatWindow = document.getElementById('chat-window');

            const existingMessage = chatWindow.querySelector(`.chat-message[data-id="${data.id}"]`);
            if (existingMessage) {
                return; // Avoid duplicating messages
            }

            const messageElement = document.createElement('div');
            const isMe = (data.sender_name === chosenUsername);
            messageElement.classList.add('chat-message', isMe ? 'chat-me' : 'chat-other');
            messageElement.setAttribute('data-id', data.id);
            messageElement.setAttribute('data-channel', data.channel);
            messageElement.setAttribute('data-sender-name', data.sender_name);
            messageElement.setAttribute('data-full-text', data.message);
            messageElement.setAttribute('data-timestamp', data.timestamp);

            messageElement.innerHTML = `
                <span class="chat-timestamp">[${data.timestamp}]</span>
                <span class="chat-sender">${data.sender_name}:</span>
                <span class="chat-text">${data.message}</span>
            `;

            chatWindow.appendChild(messageElement);

            applyFilters();
            scrollToBottom(); // Automatically scroll to the latest message
        });

        function sendMessage() {
            const messageInput = document.getElementById('message-input');
            const message = messageInput.value.trim();
            if (message !== '' && chosenUsername !== '') {
                socket.emit('send_message', { 
                    message: message, 
                    channel: selectedChannel,
                    username: chosenUsername
                });
                console.log("DEBUG: About to send image with channel=", selectedChannel);
                messageInput.value = '';
            } else if (chosenUsername === '') {
                alert("Please set a username before sending messages.");
            }
        }

        document.getElementById('send-button').addEventListener('click', sendMessage);
        document.getElementById('message-input').addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                sendMessage();
            }
        });

        function applyFilters() {
            const allMessages = document.querySelectorAll('.chat-message');
            allMessages.forEach(msg => {
                const msgChannel = msg.getAttribute('data-channel');
                if (msgChannel === selectedChannel) {
                    msg.style.display = 'block';
                } else {
                    msg.style.display = 'none';
                }
            });
        }

        const channelButtons = document.querySelectorAll('.channel-button');
        channelButtons.forEach(button => {
            button.addEventListener('click', () => {
                channelButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                selectedChannel = button.getAttribute('data-channel');
                // Save selected channel to localStorage
                localStorage.setItem('selectedChannel', selectedChannel);
                applyFilters();
            });
        });

        applyFilters();

        // Modal logic
        const modalOverlay = document.getElementById('modal-overlay');
        const modalBody = document.getElementById('modal-body');
        const closeModalBtn = document.getElementById('close-modal');
        const modalTitleElem = document.querySelector('.modal-title');

        closeModalBtn.addEventListener('click', () => {
            modalOverlay.style.display = 'none';
            modalBody.innerHTML = '';
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                modalOverlay.style.display = 'none';
                modalBody.innerHTML = '';
            }
        });

        document.getElementById('chat-window').addEventListener('click', (e) => {
            const messageElem = e.target.closest('.chat-message');
            if (messageElem) {
                const fullText = messageElem.getAttribute('data-full-text');
                const timestamp = messageElem.getAttribute('data-timestamp');
                const sender = messageElem.getAttribute('data-sender-name');
                modalTitleElem.textContent = `Full Message - [${timestamp}] [${sender}]`;
                modalBody.textContent = fullText;
                modalOverlay.style.display = 'flex';
            }
        });

        // Emoji menu logic
        const emojiButton = document.getElementById('emoji-button');
        const emojiMenu = document.getElementById('emoji-menu');
        const messageInput = document.getElementById('message-input');

        // Insert emojis into menu
        emojis.forEach(emoji => {
            const span = document.createElement('span');
            span.classList.add('emoji-item');
            span.textContent = emoji;
            span.addEventListener('click', () => {
                // Insert chosen emoji into message input
                messageInput.value += emoji;
                // Hide menu after selection
                emojiMenu.style.display = 'none';
            });
            emojiMenu.appendChild(span);
        });

        emojiButton.addEventListener('click', () => {
            // Toggle display of emoji menu
            if (emojiMenu.style.display === 'block') {
                emojiMenu.style.display = 'none';
            } else {
                emojiMenu.style.display = 'block';
            }
        });

        // Hide emoji menu if click outside
        document.addEventListener('click', (e) => {
            if (!emojiButton.contains(e.target) && !emojiMenu.contains(e.target)) {
                emojiMenu.style.display = 'none';
            }
        });

        const uploadImageButton = document.getElementById('upload-image-button');
        const imageInput = document.getElementById('image-input');

        // When user clicks the "Send Image" button, simulate clicking on the hidden file input
        uploadImageButton.addEventListener('click', () => {
            imageInput.click();
        });

        // When the file input changes (i.e. user picked an image), upload it
        imageInput.addEventListener('change', () => {
            const file = imageInput.files[0];
            if (!file) return;

            // Use FormData to send the file via fetch
            const formData = new FormData();
            formData.append('image', file);

            fetch('/upload_image', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                const imageUrl = data.imageUrl;
                // Now send the image as a message via Socket.IO, 
                // embedding it in an <img> tag:
                const payload = {
                    message: `<img src="${imageUrl}" alt="User Image">`,
                    channel: selectedChannel, // (or selectedChannel if that’s the variable)
                    username: chosenUsername
                    };
                console.log("SENDING to server:", payload);
                socket.emit('send_message', payload);
            })
            .catch(err => {
                console.error('Error uploading image', err);
            })
            .finally(() => {
                // Reset file input so user can pick again
                imageInput.value = "";
            });
        });

        // Define renderChannels at the top-level scope
        function renderChannels(channelList) {
            const channelSelect = document.getElementById('channel-select');
            channelSelect.innerHTML = ''; // Clear existing buttons
            channelList.forEach(channel => {
                const button = document.createElement('button');
                button.className = 'channel-button';
                button.dataset.channel = channel;
                button.textContent = channel.charAt(0).toUpperCase() + channel.slice(1);
                if (channel === selectedChannel) {
                    button.classList.add('active');
                }
                button.addEventListener('click', () => {
                    selectChannel(channel);
                });
                channelSelect.appendChild(button);
            });
        }

        // Keep selectChannel function outside too
        function selectChannel(channel) {
            selectedChannel = channel;
            localStorage.setItem('selectedChannel', selectedChannel);
            renderChannels(channels); // Re-render buttons to highlight the selected one
            applyFilters();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const defaultChannels = ['cameras', 'audio'];
            let channels = [...defaultChannels]; // Initialize with default channels
            const channelSelect = document.getElementById('channel-select');

            socket.on('update_channels', (data) => {
                channels = data.channels; // Update local list
                renderChannels(channels);
            });

            // Fetch channels from the server on page load
            socket.emit('get_channels');
        });


        // Add a new channels
        document.getElementById('add-channel-button').addEventListener('click', () => {
            const newChannel = prompt('Enter new channel name:').trim();
            if (newChannel && !channels.includes(newChannel)) {
                socket.emit('add_channel', { channel_name: newChannel }); // Notify server
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            // Ensure channels is populated before adding event listeners
            socket.emit('get_channels');

            // Add event listener for remove channel button
            document.getElementById('remove-channel-button').addEventListener('click', () => {
                if (!channels) {
                    alert("Channels not loaded yet. Please wait.");
                    return;
                }
                const channelToRemove = prompt('Enter channel name to remove:').trim();
                if (!channelToRemove) return;

                if (['cameras', 'audio'].includes(channelToRemove.toLowerCase())) {
                    alert(`Cannot remove default channel: ${channelToRemove}`);
                    return;
                }

                if (!channels.includes(channelToRemove)) {
                    alert(`Channel '${channelToRemove}' does not exist.`);
                    return;
                }

                // Emit removal request to the server
                socket.emit('remove_channel', { channel_name: channelToRemove });
            });
        });


            // Listen for errors or success
            socket.on('error', (data) => {
                alert(data.message); // Display error message from the server
            });

            socket.on('update_channels', (data) => {
                channels = data.channels; // Update global variable
                renderChannels(channels); // Re-render channels
                console.log("Updated channels: ", channels);
            });
      





    </script>
</body>
</html>
